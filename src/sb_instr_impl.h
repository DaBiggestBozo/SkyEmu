
// This file is autogenerated do not edit

#ifndef SB_INSTR_IMPL
#define SB_INSTR_IMPL 1

#include "sb_types.h"
#include <stdio.h>

#define SB_OP_0 0
#define SB_OP_00H 1
#define SB_OP_08H 2
#define SB_OP_1 3
#define SB_OP_10H 4
#define SB_OP_18H 5
#define SB_OP_2 6
#define SB_OP_20H 7
#define SB_OP_28H 8
#define SB_OP_3 9
#define SB_OP_30H 10
#define SB_OP_38H 11
#define SB_OP_4 12
#define SB_OP_5 13
#define SB_OP_6 14
#define SB_OP_7 15
#define SB_OP_A 16
#define SB_OP_AF 17
#define SB_OP_B 18
#define SB_OP_BC 19
#define SB_OP_BC_INDIRECT 20
#define SB_OP_C 21
#define SB_OP_C_FLAG 22
#define SB_OP_D 23
#define SB_OP_DE 24
#define SB_OP_DE_INDIRECT 25
#define SB_OP_E 26
#define SB_OP_FF00_PLUS_C_INDIRECT 27
#define SB_OP_FF00_PLUS_U8_INDIRECT 28
#define SB_OP_H 29
#define SB_OP_HL 30
#define SB_OP_HL_DEC_INDIRECT 31
#define SB_OP_HL_INC_INDIRECT 32
#define SB_OP_HL_INDIRECT 33
#define SB_OP_I8 34
#define SB_OP_L 35
#define SB_OP_NC_FLAG 36
#define SB_OP_NONE 37
#define SB_OP_NZ_FLAG 38
#define SB_OP_SP 39
#define SB_OP_SP_PLUS_I8 40
#define SB_OP_U16 41
#define SB_OP_U16_INDIRECT 42
#define SB_OP_U8 43
#define SB_OP_Z_FLAG 44

#define SB_Z_BIT 7U
#define SB_N_BIT 6U
#define SB_H_BIT 5U
#define SB_C_BIT 4U

uint16_t sb_read16(sb_gb_t *gb, int addr);
uint8_t sb_read8(sb_gb_t *gb, int addr);
void sb_store8(sb_gb_t *gb, int addr, int value);
void sb_store16(sb_gb_t *gb, int addr, unsigned int value);

void sb_set_flags(sb_gb_t *gb, const uint8_t* flag_mask, int Z, int N, int H, int C){
  
  if(flag_mask[0]=='-')Z=-1;
  if(flag_mask[1]=='-')N=-1;
  if(flag_mask[2]=='-')H=-1;
  if(flag_mask[3]=='-')C=-1;

  if(Z==-1)Z = (gb->cpu.af>>SB_Z_BIT)&1;
  if(N==-1)N = (gb->cpu.af>>SB_N_BIT)&1;
  if(H==-1)H = (gb->cpu.af>>SB_H_BIT)&1;
  if(C==-1)C = (gb->cpu.af>>SB_C_BIT)&1;
  
  Z &=1;
  N &=1;
  H &=1;
  C &=1;

  int flags = (Z<<SB_Z_BIT)|(N<<SB_N_BIT)|(H<<SB_H_BIT)|(C<<SB_C_BIT);
  gb->cpu.af = (gb->cpu.af&0xff00)|flags;
}
int sb_load_operand(sb_gb_t* gb, int operand){
  switch(operand){
    case SB_OP_0: { return 0; }
    case SB_OP_00H: { return 0; }
    case SB_OP_08H: { return 0x8; }
    case SB_OP_1: { return 1; }
    case SB_OP_10H: { return 0x10; }
    case SB_OP_18H: { return 0x18; }
    case SB_OP_2: { return 2; }
    case SB_OP_20H: { return 0x20; }
    case SB_OP_28H: { return 0x28; }
    case SB_OP_3: { return 3; }
    case SB_OP_30H: { return 0x30; }
    case SB_OP_38H: { return 0x38; }
    case SB_OP_4: { return 4; }
    case SB_OP_5: { return 5; }
    case SB_OP_6: { return 6; }
    case SB_OP_7: { return 7; }
    case SB_OP_A: { return SB_U16_HI(gb->cpu.af); }
    case SB_OP_AF: { return gb->cpu.af; }
    case SB_OP_B: { return SB_U16_HI(gb->cpu.bc); }
    case SB_OP_BC: { return gb->cpu.bc; }
    case SB_OP_BC_INDIRECT: { return sb_read8(gb,gb->cpu.bc); }
    case SB_OP_C: { return SB_U16_LO(gb->cpu.bc); }
    case SB_OP_C_FLAG: { return ((gb->cpu.af>>SB_C_BIT)&0x1); }
    case SB_OP_D: { return SB_U16_HI(gb->cpu.de); }
    case SB_OP_DE: { return gb->cpu.de; }
    case SB_OP_DE_INDIRECT: { return sb_read8(gb,gb->cpu.de); }
    case SB_OP_E: { return SB_U16_LO(gb->cpu.de); }
    /*case SB_OP_FF00_PLUS_C_INDIRECT: { return sb_read16(gb, 0xff00+SB_U16_LO(gb->cpu.bc));; }*/
    case SB_OP_FF00_PLUS_U8_INDIRECT: { return sb_read8(gb, 0xff00|sb_read8(gb, gb->cpu.pc-1)); }
    case SB_OP_H: { return SB_U16_HI(gb->cpu.hl); }
    case SB_OP_HL: { return SB_U16_LO(gb->cpu.hl); }
    case SB_OP_HL_DEC_INDIRECT: { return sb_read8(gb,gb->cpu.hl--); }
    case SB_OP_HL_INC_INDIRECT: { return sb_read8(gb,gb->cpu.hl++); }
    case SB_OP_HL_INDIRECT: { return sb_read8(gb,gb->cpu.hl); }
    case SB_OP_I8: { return (int8_t)sb_read8(gb,gb->cpu.pc-1); }
    case SB_OP_L: { return SB_U16_LO(gb->cpu.hl); }
    case SB_OP_NC_FLAG: { return ((gb->cpu.af>>SB_C_BIT)&0x1)==0; }
    case SB_OP_NONE: { return 0; }
    case SB_OP_NZ_FLAG: { return ((gb->cpu.af>>SB_Z_BIT)&0x1)==0; }
    case SB_OP_SP: { return gb->cpu.sp; }
    case SB_OP_SP_PLUS_I8: { return gb->cpu.sp+(int8_t)sb_read8(gb,gb->cpu.pc-1); }
    case SB_OP_U16: { return sb_read16(gb, gb->cpu.pc-2); }
    case SB_OP_U16_INDIRECT: { return sb_read16(gb, sb_read16(gb, gb->cpu.pc-2)); }
    case SB_OP_U8: { return sb_read8(gb, gb->cpu.pc-1); }
    case SB_OP_Z_FLAG: { return ((gb->cpu.af>>SB_Z_BIT)&0x1); }
  }
  printf("Unhandled read operand %d\n",operand);
  return 0;
}

void sb_store_operand(sb_gb_t* gb, int operand, int value){
  switch(operand){
    case SB_OP_A: { SB_U16_HI_SET(gb->cpu.af,value); return; }
    case SB_OP_AF: { gb->cpu.af = value; return; }
    case SB_OP_B: { SB_U16_HI_SET(gb->cpu.bc,value);return; }
    case SB_OP_BC: { gb->cpu.bc = value; return; }
    case SB_OP_BC_INDIRECT: { return sb_store8(gb,gb->cpu.bc, value); }
    case SB_OP_C: { SB_U16_LO_SET(gb->cpu.bc,value);return; }
    case SB_OP_D: { SB_U16_HI_SET(gb->cpu.de,value);return; }
    case SB_OP_DE: { gb->cpu.de = value; return; }
    case SB_OP_DE_INDIRECT: { return sb_store8(gb,gb->cpu.de, value); }
    case SB_OP_E: { SB_U16_LO_SET(gb->cpu.de,value);return; }
    //case SB_OP_FF00_PLUS_C_INDIRECT: {
    //  return sb_store8(gb,0xff00+SB_U16_LO(gb->cpu.bc), value);
    //}
    case SB_OP_FF00_PLUS_U8_INDIRECT: {
      return sb_store8(gb,0xff00+sb_read8(gb,gb->cpu.pc-1), value);
    }
    case SB_OP_H: { SB_U16_HI_SET(gb->cpu.hl,value);return; }
    case SB_OP_HL: { gb->cpu.hl = value; return; }
    case SB_OP_HL_DEC_INDIRECT: { return sb_store8(gb,gb->cpu.hl--, value); }
    case SB_OP_HL_INC_INDIRECT: { return sb_store8(gb,gb->cpu.hl++, value); }
    case SB_OP_HL_INDIRECT: { return sb_store8(gb,gb->cpu.hl, value); }
    case SB_OP_L: { SB_U16_LO_SET(gb->cpu.hl,value);return; }
    case SB_OP_SP: { gb->cpu.sp = value; return; }
    case SB_OP_SP_PLUS_I8: { return sb_store8(gb,gb->cpu.sp+(int8_t)sb_read8(gb,gb->cpu.pc-1), value); }
    case SB_OP_U16_INDIRECT: { return sb_store8(gb,sb_read16(gb, gb->cpu.pc-2), value); }

  }
  printf("Unhandled write operand %d\n",operand);
  return;
}

static void sb_adc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode ADC executed\n");
}

static void sb_add_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode ADD executed\n");
}

static void sb_and_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode AND executed\n");
}

static void sb_bit_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode BIT executed\n");
}

static void sb_call_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  gb->cpu.sp-=2;
  sb_store16(gb,gb->cpu.sp,gb->cpu.pc);
  gb->cpu.pc = op1;
}

static void sb_callc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  if(op1)sb_call_impl(gb, op2, 0, 0,flag_mask);
}

static void sb_ccf_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode CCF executed\n");
}

static void sb_cp_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode CP executed\n");
}

static void sb_cpl_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode CPL executed\n");
}

static void sb_daa_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode DAA executed\n");
}

static void sb_dec_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  int r = op1-1;
  sb_set_flags(gb, flag_mask, (r&0xff)==0,1,((r^op1)>>5)==1,-1);
  sb_store_operand(gb,op1_enum, r);
}

static void sb_di_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  gb->cpu.interrupt_enable = false;
}

static void sb_ei_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  gb->cpu.interrupt_enable = true;
}

static void sb_halt_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode HALT executed\n");
}

static void sb_inc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  int r = op1+1;
  sb_set_flags(gb,flag_mask, (r&0xff)==0,0,((r^op1)>>5)==1,-1);
  sb_store_operand(gb,op1_enum, r);
}

static void sb_jp_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  gb->cpu.pc = op1;
}

static void sb_jpc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  if(op1)sb_jp_impl(gb, op2, 0, 0,flag_mask);
}

static void sb_jr_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  gb->cpu.pc += op1;
}

static void sb_jrc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  if(op1) sb_jr_impl(gb, op2, 0, 0,flag_mask);
}

static void sb_ld_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  sb_store_operand(gb,op1_enum,op2);
}

static void sb_nop_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
}

static void sb_nop_no_instr_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode NOP_NO_INSTR executed\n");
}

static void sb_or_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode OR executed\n");
}

static void sb_pop_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  sb_store_operand(gb,op1_enum,sb_read16(gb,gb->cpu.sp));
  gb->cpu.sp+=2;
}

static void sb_prefix_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode PREFIX executed\n");
}

static void sb_push_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  gb->cpu.sp-=2;
  sb_store16(gb,gb->cpu.sp,op1);
}

static void sb_res_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RES executed\n");
}

static void sb_ret_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  gb->cpu.pc=sb_read16(gb,gb->cpu.sp);
  gb->cpu.sp+=2;
}

static void sb_retc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  if(op1)sb_ret_impl(gb, op2, 0, 0,flag_mask);
}

static void sb_reti_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RETI executed\n");
}

static void sb_rl_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RL executed\n");
}

static void sb_rla_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RLA executed\n");
}

static void sb_rlc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RLC executed\n");
}

static void sb_rlca_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RLCA executed\n");
}

static void sb_rr_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RR executed\n");
}

static void sb_rra_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RRA executed\n");
}

static void sb_rrc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RRC executed\n");
}

static void sb_rrca_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RRCA executed\n");
}

static void sb_rst_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode RST executed\n");
}

static void sb_sbc_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SBC executed\n");
}

static void sb_scf_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SCF executed\n");
}

static void sb_set_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SET executed\n");
}

static void sb_sla_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SLA executed\n");
}

static void sb_sra_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SRA executed\n");
}

static void sb_srl_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SRL executed\n");
}

static void sb_stop_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode STOP executed\n");
}

static void sb_sub_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SUB executed\n");
}

static void sb_swap_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode SWAP executed\n");
}

static void sb_xor_impl(sb_gb_t* gb, int op1, int op2, int op1_enum, const uint8_t * flag_mask){
  printf("Stubbed opcode XOR executed\n");
}

#endif
