def bfe(value, bitoffset, size):
  return ((value >> bitoffset) & ((1<< size) - 1));

def gen_parameter_list(pattern,isa):
  curr_param = '-';
  curr_start = 0;
  curr_size = 0;
  params=[]
  pattern_len = 28
  if isa == "thumb16": pattern_len = 16
  for i in range(0,pattern_len):
    letter = pattern[len(pattern)-i-1];
    if letter!=curr_param:
      if curr_param not in "01-":
        params += [[curr_param, curr_start, curr_size]]
      curr_size = 0;
      curr_param = letter
      curr_start = i;
    curr_size+=1;
  return params;  


for isa in ["arm","thumb16"]:
  optable ={}
  needed_functions = []           
  internal_op_table =[]
  with open(f'docs/{isa}.inc',"r") as f:
    intern_op = 0; 
    for line in f.readlines():
      if len(line)<2: continue;
      if(line[0]=='/' and line[1] =='/'): continue;
      inst = line; 
      version = "v1"
      if "//" in line: 
        (inst, version) = line.split("//");
  
      version = version.strip();
      if version[0] != 'v': continue
      if int(version[1]) > 4: continue
      inst = inst.strip();
      inst = inst.split("INST(")[1].rsplit(")",1)[0];
                                                      
      print(inst)
      (handler, pneumonic, pattern) = inst.split(",");
      pattern = pattern.replace('"',"").strip();
      
      parameter_ranges = gen_parameter_list(pattern,isa);
  
      for l in "tvmnxcwSdArsDpuOMonNa":
        pattern = pattern.replace(l,"-");
  
      pneumonic = pneumonic.replace('"',"").strip();
      print(handler, pneumonic, pattern, version);
      needed_functions+=[handler];
  
      optable[pneumonic] = {
        "pattern": pattern,
        "handler": handler,
        "intern_op": intern_op,
        "params" : parameter_ranges
      };
      internal_op_table += [pneumonic]
      intern_op+=1;
                                       
  def match_op(optable, arm_op):
    best_match_bits = -1; 
    best_match_name = "unknown"
  
    for opname in optable:
      pattern = optable[opname]["pattern"];
      bits = 0;
      match = True;
      for i in range(0,len(pattern)):
        if isa == "arm":
          if i>27: continue
          if i<20 and i>7:continue
          if i<4: continue;
        elif isa =="thumb16":
          if i<6: continue;
        else: raise("Unknown isa"+isa);
        bit1 = bfe(arm_op,i,1);
        pat_bit = pattern[len(pattern)-i];
        if pat_bit == '-': continue;
        if pat_bit == '0' and bit1 !=0: match = False; break;
        if pat_bit == '1' and bit1 !=1: match = False; break;
        bits +=1
      if match and bits > best_match_bits:
        best_match_bits = bits;
        best_match_name = opname;
  
    return best_match_name; 
  
  
  
  decode_table = f"  static const uint16_t conv_{isa}_intern_op[]={{\n";
  count = 0; 
  for lookup_op in range(0,4096):
    bits7_4 = bfe(lookup_op,0,4);
    bits27_20 = bfe(lookup_op,4,8);
  
    arm_op = (bits7_4<<4) | (bits27_20<<20)
  
    decoded_op = match_op(optable,arm_op);
    opvalue = optable[decoded_op]["intern_op"];
  
    if count==0: decode_table+='   ';
    decode_table+=f' {opvalue},';
    count +=1
    if(count>=16):
      count =0;
      decode_table+='\n';
    
  decode_table+="  };\n";
  
  disasm_table = f"static const char * gba_{isa}_disasm_name[]={{\n";
  count = 0; 
  for op in internal_op_table:
    if count==0: disasm_table+=' ';
    disasm_table+=f' "{op}",';
    count +=1
    if(count>=8):
      count =0;
      disasm_table+='\n';
     
  disasm_table+="};\n";
  
  
  dispatch_table =  f"""
  void gba_execute_{isa}_instr(gba_t* gba, uint32_t opcode){{\n
    int intern_op = gba_intern_op(opcode);
    switch(intern_op){{
  """
  
  for i in range(0,len(internal_op_table)):
    func = optable[internal_op_table[i]]["handler"]
    dispatch_table += f"    case {i}: {func}(gba, opcode);break;\n"
  
  dispatch_table+="""
    };
  }
  """
  param_decode_table = """
  typedef struct { struct{uint8_t name, start, size;} params[10];} arm7tdmi_param_t;
  const static arm7tdmi_param_t arm7tdmi_params[]={\n
  """ 
   
  for i in range(0,len(internal_op_table)):
    params = optable[internal_op_table[i]]["params"]
    param_decode_table +="  {{";
    for p in params:
      param_decode_table += f"{{'{p[0]}',{p[1]},{p[2]}}},"
    param_decode_table += f"{{'\\0',0,0}},"
    param_decode_table +="}},\n";
  
  param_decode_table+="};\n";
  
  with open(f"src/gba_{isa}_tables.h","w") as f:
  
    f.write("""
  // Copyright Skyler Saleh
  // 
  // Autogenerated decoding tables. Do not modify by hand. 
  
  #ifndef GBA_TABLES_H
  #define GBA_TABLES_H 1
  #include "arm7tdmi_instr.h"
  
  // internal opcode = {arm_op[27:20],arm_op[7:0}
  static inline int gba_intern_op(uint32_t arm_op){""")
    f.write(decode_table);
    f.write("""
    return conv_intern_op[((arm_op>>4)&0xf) | (((arm_op>>20)&0xff)<<4)];
  }
  // Table to map interal opcodes to pneumonics
  """);
    f.write(disasm_table);
  
    f.write(param_decode_table);  
    f.write(dispatch_table);  
    f.write("#endif\n");
  
  generate_prototypes = False;
  if generate_prototypes:
    generated ={}
    with open(f"src/{isa}_instr_tmp.h","w") as f:
      for iop in internal_op_table:
        funct = optable[iop]["handler"]
        if funct in generated: continue
        generated[funct]=1;
        f.write(f"static inline void {funct}(gba_t *gba, uint32_t opcode){{\n");
        for p in optable[iop]["params"]:
          f.write(f"  int {p[0]} = SB_BFE(opcode,{p[1]},{p[2]});\n");
        if "reg" in iop or "rsr" in iop:
          f.write("bool carry; m = arm7tdmi_load_shift_reg(&(gba->cpu),opcode,m,&carry); \n")
        f.write("  {\n");
        f.write(f'    printf("Hit Unimplemented {iop} %x\\n",opcode);\n');
        f.write("  }\n");
        f.write('  gba->cpu.trigger_breakpoint = true;\n');
        f.write('}\n');
        
